Steps involved in a binary reconnection PIC code:

- Initialise the simulation parameters: the grid size, the number of time steps, and the particle parameters.
- Initialise the grid, electric and magnetic fields and the particle position, velocity, and charge.
- The time loop, where in each time step the particles are moved based on their velocity, and the fields are advanced using MHD equations.
- Interpolating the particle properties to the grid.
- Checking for binary reconnection by checking our criteria. We assume reconnection MUST happen for simplicity? i.e. close enough.
- Updating the particle velocity due to reconnection.
- Plotting/saving the fields and particles.

The following is pseudocode for modelling 2D binary reconnection using PIC method based on paper 1 (Notion)

# Initialize simulation parameters
nx, ny = 128, 128  # Number of grid cells in x and y
nt = 10000  # Number of time steps

# Initialize the grid and particle arrays
Ex, Ey, Bz = np.zeros((nx, ny)), np.zeros((nx, ny)), np.zeros((nx, ny))
x, y, ux, uy, q = [], [], [], [], []

# Initialize the particles
for i in range(n_particles):
    x.append(np.random.uniform(0, nx))
    y.append(np.random.uniform(0, ny))
    ux.append(np.random.normal(0, 0.1))
    uy.append(np.random.normal(0, 0.1))
    q.append(np.random.choice([-1, 1]))

# Time loop
for i in range(nt):
    # Move the particles. This is where the random walk setup would need to come in play.
    for j in range(n_particles):
        x[j] += ux[j]
        y[j] += uy[j]
        # Apply periodic boundary conditions
        x[j] = x[j] % nx
        y[j] = y[j] % ny

    # Interpolate the particle positions to the grid
    Ex, Ey = interpolate_to_grid(x, y, ux, uy, q)

    # Advance the electric and magnetic fields
    Bz[:,:] += dBzdt(Ex, Ey)
    Ex[:,:] += dExdt(Bz)
    Ey[:,:] += dEydt(Bz)
    # Check for reconnection
    reconnection_mask = check_reconnection(Ex, Ey)
    # Update the particle velocity
    update_particle_velocity(reconnection_mask, x, y, ux, uy)


